{
  "src": {
    "main": {
      "java": {
        "com": {
          "demo": {
            "demo": {
              "config": {
                "JwtAuthenticationFilter.java": "package com.demo.demo.config;\r\n\r\npublic class JwtAuthenticationFilter {\r\n}\r\n",
                "security": {
                  "AuthenticationConfig.java": "package com.demo.demo.config.security;\r\n\r\nimport com.demo.demo.services.UserService;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.dao.DaoAuthenticationProvider;\r\nimport org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;\r\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\n\r\n@Configuration\r\n@RequiredArgsConstructor\r\npublic class AuthenticationConfig {\r\n    private final UserService userDetailsService;\r\n\r\n    @Bean\r\n    public PasswordEncoder passwordEncoder() {\r\n        return new BCryptPasswordEncoder();\r\n    }\r\n    @Bean\r\n    public AuthenticationManager authenticationManager(\r\n            AuthenticationConfiguration authConfig) throws Exception {\r\n        return authConfig.getAuthenticationManager();\r\n    }\r\n\r\n    @Bean\r\n    public DaoAuthenticationProvider authenticationProvider() {\r\n        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();\r\n        provider.setUserDetailsService(userDetailsService);\r\n        provider.setPasswordEncoder(passwordEncoder());\r\n        return provider;\r\n    }\r\n}\r\n",
                  "CurrentUser.java": "package com.demo.demo.config.security;\r\n\r\n\r\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\r\n\r\nimport java.lang.annotation.*;\r\n\r\n@Target({ ElementType.PARAMETER, ElementType.TYPE })\r\n@Retention(RetentionPolicy.RUNTIME)\r\n@Documented\r\n@AuthenticationPrincipal\r\npublic @interface CurrentUser {\r\n}\r\n",
                  "JwtAuthenticationFilter.java": "package com.demo.demo.config.security;\r\n\r\nimport jakarta.servlet.FilterChain;\r\nimport jakarta.servlet.ServletException;\r\nimport jakarta.servlet.http.HttpServletRequest;\r\nimport jakarta.servlet.http.HttpServletResponse;\r\nimport lombok.RequiredArgsConstructor;\r\nimport lombok.extern.slf4j.Slf4j;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.core.context.SecurityContextHolder;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.web.authentication.WebAuthenticationDetailsSource;\r\nimport org.springframework.util.StringUtils;\r\nimport org.springframework.web.filter.OncePerRequestFilter;\r\n\r\nimport java.io.IOException;\r\n\r\n@Configuration\r\n@RequiredArgsConstructor\r\n@Slf4j\r\npublic class JwtAuthenticationFilter extends OncePerRequestFilter {\r\n    private final   UserDetailsService userDetailsService;\r\n    private final JwtUtil jwtUtil;\r\n\r\n    @Override\r\n    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)\r\n            throws ServletException, IOException {\r\n        final String token = getTokenFromRequest(request);\r\n        String username = null;\r\n        if (token == null) {\r\n            filterChain.doFilter(request, response);\r\n            return;\r\n        }\r\n       try {\r\n           username = jwtUtil.getUsernameFromToken(token);\r\n       }catch (IllegalArgumentException e) {\r\n           logger.info(e.getMessage());\r\n           filterChain.doFilter(request, response);\r\n       }\r\n        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {\r\n            UserDetails user = userDetailsService.loadUserByUsername(username);\r\n            if (jwtUtil.isTokenValid(token, user)) {\r\n                UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(user, null,\r\n                        user.getAuthorities());\r\n\r\n                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));\r\n                SecurityContextHolder.getContext().setAuthentication(authToken);\r\n            }\r\n        }\r\n        filterChain.doFilter(request, response);\r\n    }\r\n\r\n    private String getTokenFromRequest(HttpServletRequest request) {\r\n        final String token = request.getHeader(HttpHeaders.AUTHORIZATION);\r\n        if (StringUtils.hasText(token) && token.startsWith(\"Bearer \")) {\r\n            return token.substring(7);\r\n        }\r\n        return null;\r\n    }\r\n    }",
                  "JwtUtil.java": "package com.demo.demo.config.security;\r\n\r\nimport io.jsonwebtoken.Claims;\r\nimport io.jsonwebtoken.JwtException;\r\nimport io.jsonwebtoken.Jwts;\r\nimport io.jsonwebtoken.security.Keys;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.security.core.GrantedAuthority;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.stereotype.Component;\r\n\r\nimport javax.crypto.SecretKey;\r\nimport java.util.Date;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\nimport java.util.function.Function;\r\nimport java.util.stream.Collectors;\r\n\r\n@Component\r\npublic class JwtUtil {\r\n\r\n//    private final SecretKey SECRET_KEY = Keys.secretKeyFor(SignatureAlgorithm.HS256);\r\n\r\n    @Value(\"${jwt.secret}\")\r\n    private  String JWT_SECRET ;\r\n    public Date expiration() {\r\n        return new Date(System.currentTimeMillis() + 1000 * 60 * 60);\r\n    }\r\n    private SecretKey getKey() {\r\n        return Keys.hmacShaKeyFor(JWT_SECRET.getBytes());\r\n    }\r\n    public String createToken(String username, Map<String, Object> claims) {\r\n\r\n        return Jwts.builder()\r\n                .addClaims(claims)\r\n                .setSubject(username)\r\n                .setIssuedAt(new Date(System.currentTimeMillis()))\r\n                .setExpiration(expiration())\r\n                .signWith(getKey())\r\n                .compact();\r\n    }\r\n\r\n    public String generateToken(UserDetails userDetails) {\r\n        Map<String, Object> claims = new HashMap<>();\r\n        claims.put(\"roles\", userDetails.getAuthorities().stream()\r\n                .map(GrantedAuthority::getAuthority)\r\n                .collect(Collectors.toList()));\r\n\r\n        return createToken(userDetails.getUsername(), claims);\r\n    }\r\n\r\n    public String generateToken(String username) {\r\n        return Jwts.builder()\r\n                .setSubject(username)\r\n                .setIssuedAt(new Date())\r\n                .setExpiration(new Date(System.currentTimeMillis() + 1000 * 60 * 60 * 10)) // 10 horas\r\n                .signWith(getKey()) // Usa la clave generada\r\n                .compact();\r\n    }\r\n\r\n    public String extractUsername(String token) {\r\n        return Jwts.parserBuilder()\r\n                .setSigningKey(getKey()) // Configura la misma clave para validación\r\n                .build()\r\n                .parseClaimsJws(token)\r\n                .getBody()\r\n                .getSubject();\r\n    }\r\n\r\n\r\n    public <T> T getClaim(String token, Function<Claims, T> claimsResolver) {\r\n        Claims claimis = getAllClaims(token);\r\n        return claimsResolver.apply(claimis);\r\n    }\r\n\r\n    private Claims getAllClaims(String token) {\r\n\r\n        try {\r\n            return Jwts.parserBuilder()\r\n                    .setSigningKey(getKey())\r\n                    .build()\r\n                    .parseClaimsJws(token)\r\n                    .getBody();\r\n        } catch (JwtException e) {\r\n\r\n            throw new IllegalArgumentException(\"Token inválido\", e);\r\n        }\r\n        }\r\n\r\n    public String getUsernameFromToken(String token) {\r\n        return getClaim(token, Claims::getSubject);\r\n    }\r\n\r\n    public boolean isTokenValid(String token, UserDetails userDetails) {\r\n        final String username = getUsernameFromToken(token);\r\n\r\n        return (username.equals(userDetails.getUsername()) && !isTokenExpired(token));\r\n    }\r\n\r\n    public Date getExpiration(String token) {\r\n        return getClaim(token, Claims::getExpiration);\r\n    }\r\n\r\n    public boolean isTokenExpired(String token) {\r\n        return getExpiration(token).before(new Date());\r\n    }\r\n}",
                  "SecurityConfig.java": "package com.demo.demo.config.security;\r\n\r\n\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.context.annotation.Bean;\r\nimport org.springframework.context.annotation.Configuration;\r\nimport org.springframework.http.HttpMethod;\r\n\r\nimport org.springframework.security.authentication.AuthenticationProvider;\r\n\r\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\r\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\r\nimport org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;\r\nimport org.springframework.security.config.http.SessionCreationPolicy;\r\n\r\nimport org.springframework.security.web.SecurityFilterChain;\r\n\r\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\r\n\r\n@Configuration\r\n@EnableWebSecurity\r\n@RequiredArgsConstructor\r\npublic class SecurityConfig {\r\n\r\n    private final AuthenticationProvider authenticationProvider;\r\n    private final JwtAuthenticationFilter jwtAuthenticationFilter;\r\n    @Bean\r\n    SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {\r\n        http\r\n                .authorizeHttpRequests(auth -> {\r\n                    auth.requestMatchers( \"/api/auth/**\").permitAll();\r\n                    auth.requestMatchers(HttpMethod.GET,\"/api/auth/check-login\").hasRole(\"USER\");\r\n                    auth.anyRequest().authenticated();\r\n                })\r\n                .csrf(AbstractHttpConfigurer::disable)\r\n                .sessionManagement(session -> session\r\n                        .sessionCreationPolicy(SessionCreationPolicy.STATELESS))\r\n                .authenticationProvider(authenticationProvider)\r\n                .addFilterBefore(jwtAuthenticationFilter,\r\n                        UsernamePasswordAuthenticationFilter.class)\r\n                .securityContext(context -> context.requireExplicitSave(true));\r\n        return http.build();\r\n    }\r\n\r\n}\r\n"
                }
              },
              "controllers": {
                "AuthController.java": "package com.demo.demo.controllers;\r\n\r\nimport com.demo.demo.dtos.request.LoginRequestDto;\r\nimport com.demo.demo.dtos.request.RegisterRequestDto;\r\nimport com.demo.demo.dtos.response.AuthResponseDto;\r\nimport com.demo.demo.entities.UserEntity;\r\nimport com.demo.demo.services.AuthService;\r\nimport com.demo.demo.config.security.CurrentUser;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.security.core.annotation.AuthenticationPrincipal;\r\nimport org.springframework.security.oauth2.core.user.OAuth2User;\r\nimport org.springframework.web.bind.annotation.*;\r\n\r\n@RestController\r\n@RequestMapping(\"/api/auth\")\r\n@RequiredArgsConstructor\r\npublic class AuthController {\r\n\r\n\r\n    private final AuthService authService;\r\n\r\n\r\n    @PostMapping(\"/register\")\r\n    public ResponseEntity<AuthResponseDto> register(@RequestBody RegisterRequestDto dto) {\r\n       return ResponseEntity.status(201).body(authService.register(dto));\r\n    }\r\n\r\n\r\n    @PostMapping(\"/login\")\r\n    public ResponseEntity<AuthResponseDto> login(@RequestBody LoginRequestDto dto) {\r\n        return ResponseEntity.status(200).body(authService.login(dto));\r\n    }\r\n    @PostMapping(\"/login/oauth2/google\")\r\n    public ResponseEntity<String> loginGoogle() {\r\n        return ResponseEntity.status(200).body(\"Google Login\");\r\n    }\r\n\r\n\r\n    @GetMapping(\"/check-login\")\r\n    public ResponseEntity<UserEntity> checkLogin(@CurrentUser UserEntity user) {\r\n        return ResponseEntity.status(200).body(user);\r\n    }\r\n\r\n    @GetMapping\r\n    public ResponseEntity<String> auth(@AuthenticationPrincipal OAuth2User user) {\r\n        return ResponseEntity.ok().body(user.getName());\r\n    }\r\n}\r\n",
                "GoogleAuthController.java": "package com.demo.demo.controllers;\r\n\r\nimport com.demo.demo.config.security.JwtUtil;\r\nimport com.demo.demo.dtos.request.TokenRequestDto;\r\nimport com.demo.demo.dtos.response.AuthResponseDto;\r\nimport com.demo.demo.entities.RoleEntity;\r\nimport com.demo.demo.entities.UserEntity;\r\nimport com.demo.demo.exceptions.NotFoundException;\r\nimport com.demo.demo.repositories.RoleRepository;\r\nimport com.demo.demo.repositories.UserRepository;\r\nimport com.google.api.client.googleapis.auth.oauth2.GoogleIdToken;\r\nimport com.google.api.client.googleapis.auth.oauth2.GoogleIdTokenVerifier;\r\nimport com.google.api.client.http.javanet.NetHttpTransport;\r\nimport com.google.api.client.json.jackson2.JacksonFactory;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.beans.factory.annotation.Value;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.stereotype.Controller;\r\nimport org.springframework.web.bind.annotation.PostMapping;\r\nimport org.springframework.web.bind.annotation.RequestBody;\r\nimport org.springframework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\nimport java.io.IOException;\r\nimport java.security.GeneralSecurityException;\r\nimport java.util.Collections;\r\n\r\n@RestController\r\n@RequiredArgsConstructor\r\n@RequestMapping(\"/api/auth\")\r\npublic class GoogleAuthController {\r\n\r\n  @Value(\"${google.client-id}\")\r\n    private String CLIENT_ID;\r\n\r\n    private final JwtUtil jwtUtil;\r\n    private final UserRepository userRepository;\r\n    private final RoleRepository roleRepository;\r\n\r\n    @PostMapping(\"/verify-token\")\r\n    public ResponseEntity<?> verifyGoogleToken(@RequestBody TokenRequestDto tokenRequest) {\r\n        try {\r\n            // Configurar el verificador\r\n            GoogleIdTokenVerifier verifier = new GoogleIdTokenVerifier.Builder(\r\n                    new NetHttpTransport(),\r\n                    new JacksonFactory()\r\n            )\r\n                    .setAudience(Collections.singletonList(CLIENT_ID))\r\n                    .build();\r\n\r\n            // Verificar el token de Google\r\n            GoogleIdToken idToken = verifier.verify(tokenRequest.idToken());\r\n\r\n            if (idToken != null) {\r\n                GoogleIdToken.Payload payload = idToken.getPayload();\r\n\r\n                // Obtener el email del usuario y name\r\n                String email = payload.getEmail();\r\n                String name = (String) payload.get(\"name\");\r\n\r\n                // Verificar si el usuario existe en la base de datos\r\n                UserEntity user = userRepository.findByUsername(email).orElseGet(() -> {\r\n                    // Crear un nuevo usuario si no existe\r\n                    UserEntity newUser = new UserEntity();\r\n                    newUser.setUsername(email);\r\n                    newUser.setName(name);\r\n\r\n                    RoleEntity role = roleRepository.findRoleByName(\"ROLE_USER\").orElseThrow(() -> new NotFoundException(String.format(\"Role not found with name %s\",\"ROLE_USER\")));\r\n                    newUser.getRoles().add(role);\r\n\r\n                    return userRepository.save(newUser);\r\n                });\r\n\r\n                // Generar el JWT para tu backend\r\n                String accessToken = jwtUtil.generateToken( user);\r\n\r\n                // Respuesta con el access token y el ID del usuario\r\n                return ResponseEntity.ok(new AuthResponseDto(accessToken) );\r\n            } else {\r\n                return ResponseEntity.status(400).body(\"Invalid ID token.\");\r\n            }\r\n        } catch (GeneralSecurityException | IOException e) {\r\n            return ResponseEntity.status(500).body(\"Error validating token: \" + e.getMessage());\r\n        }\r\n    }\r\n\r\n}\r\n",
                "HomeController.java": "package com.demo.demo.controllers;\r\n\r\nimport org.springframework.web.bind.annotation.GetMapping;\r\nimport org.springframework.web.bind.annotation.RestController;\r\n\r\n@RestController\r\npublic class HomeController {\r\n\r\n    @GetMapping(\"/\")\r\n    public String home() {return \"Hello, Home!\";}\r\n\r\n    @GetMapping(\"/secured\")\r\n    public String secured() {return \"Hello, secured!\";}\r\n}\r\n"
              },
              "DemoApplication.java": "package com.demo.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class DemoApplication {\n\n\tpublic static void main(String[] args) {\n\t\tSpringApplication.run(DemoApplication.class, args);\n\t}\n\n}\n",
              "dtos": {
                "request": {
                  "LoginRequestDto.java": "package com.demo.demo.dtos.request;\r\n\r\n\r\nimport jakarta.validation.constraints.Email;\r\nimport jakarta.validation.constraints.NotBlank;\r\nimport jakarta.validation.constraints.Pattern;\r\nimport lombok.*;\r\n\r\n@Setter\r\n@Getter\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class LoginRequestDto {\r\n    @Email(message = \"invalid email entered\")\r\n    @NotBlank(message = \"Email must be required\")\r\n    private String email;\r\n\r\n    @NotBlank(message = \"Password cannot be empty\")\r\n    @Pattern(\r\n            regexp = \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?&])[A-Za-z\\\\d@$!%*?&]{8,}$\",\r\n            message = \"The password must contain at least 8 characters, one uppercase letter, one lowercase letter, one number and one special character\"\r\n    )\r\n    private String password;\r\n}\r\n",
                  "RegisterRequestDto.java": "package com.demo.demo.dtos.request;\r\nimport jakarta.validation.constraints.*;\r\nimport lombok.*;\r\n\r\n@Setter\r\n@Getter\r\n@AllArgsConstructor\r\n@NoArgsConstructor\r\npublic class RegisterRequestDto {\r\n    @Email(message = \"invalid email entered\")\r\n    @NotBlank(message = \"Email must be required\")\r\n    private String email;\r\n\r\n    @NotBlank(message = \"Password cannot be empty\")\r\n    @Pattern(\r\n            regexp = \"^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)(?=.*[@$!%*?&])[A-Za-z\\\\d@$!%*?&]{8,}$\",\r\n            message = \"The password must contain at least 8 characters, one uppercase letter, one lowercase letter, one number and one special character\"\r\n    )\r\n    private String password;\r\n\r\n    @NotBlank(message = \"Password confirmation cannot be empty\")\r\n    private String confirmPassword;\r\n\r\n    @AssertTrue(message = \"Passwords do not match\")\r\n    private boolean isValidPassword() {\r\n        return password != null && password.equals(confirmPassword);\r\n    }\r\n\r\n}\r\n",
                  "TokenRequestDto.java": "package com.demo.demo.dtos.request;\r\n\r\npublic record TokenRequestDto(String idToken) {\r\n}\r\n"
                },
                "response": {
                  "AuthResponseDto.java": "package com.demo.demo.dtos.response;\r\n\r\npublic record AuthResponseDto(\r\n    String token\r\n) {\r\n}\r\n"
                }
              },
              "entities": {
                "RoleEntity.java": "package com.demo.demo.entities;\r\n\r\nimport jakarta.persistence.*;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\n\r\nimport java.util.UUID;\r\n\r\n@Entity\r\n@Table(name = \"roles\")\r\n@Getter\r\n@Setter\r\npublic class RoleEntity {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.UUID)\r\n    @Column(name = \"role_id\")\r\n    private UUID roleId;\r\n    private String roleName;\r\n}\r\n",
                "UserEntity.java": "package com.demo.demo.entities;\r\n\r\nimport jakarta.persistence.*;\r\nimport lombok.*;\r\nimport org.springframework.security.core.GrantedAuthority;\r\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\n\r\nimport java.util.*;\r\nimport java.util.stream.Collectors;\r\n\r\n@Entity\r\n@Table(name = \"users\")\r\n@Setter\r\n@Getter\r\n@Builder\r\n@NoArgsConstructor\r\n@AllArgsConstructor\r\npublic class UserEntity implements UserDetails {\r\n    @Id\r\n    @GeneratedValue(strategy = GenerationType.UUID)\r\n    @Column(name = \"user_id\")\r\n    private UUID userId;\r\n\r\n    @Column(unique = true, nullable = false)\r\n    private String username; //es el mail\r\n\r\n    @Column()\r\n    private String name;\r\n\r\n    @Column()\r\n    private String password;\r\n\r\n\r\n\r\n\r\n    @ManyToMany(fetch = FetchType.EAGER)\r\n    @JoinTable(\r\n            name = \"user_role\",\r\n            joinColumns = @JoinColumn(name = \"user_id\", referencedColumnName = \"user_id\"),\r\n            inverseJoinColumns = @JoinColumn(name = \"role_id\", referencedColumnName = \"role_id\")\r\n    )\r\n    private Set<RoleEntity> roles = new HashSet<>();\r\n\r\n    @Override\r\n    public Collection<? extends GrantedAuthority> getAuthorities() {\r\n        return roles.stream()\r\n                .map(role -> new SimpleGrantedAuthority(role.getRoleName()))\r\n                .collect(Collectors.toList());\r\n    }\r\n}\r\n"
              },
              "enums": {
                "FinancialKnowledge.java": "package com.demo.demo.enums;\r\n\r\npublic enum FinancialKnowledge {\r\n    baja, media, avanzada\r\n}\r\n",
                "MainGoal.java": "package com.demo.demo.enums;\r\n\r\npublic enum MainGoal {\r\n    ahorro, inversiones, retiro, etc\r\n}\r\n",
                "RiskPreference.java": "package com.demo.demo.enums;\r\n\r\npublic enum RiskPreference {\r\n    conservador, moderado , arriesgado\r\n}\r\n"
              },
              "exceptions": {
                "BadRequestException.java": "package com.demo.demo.exceptions;\r\n\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\n\r\n@Getter\r\n@Setter\r\npublic class BadRequestException extends RuntimeException {\r\n    private Integer statusCode = 400;\r\n    public BadRequestException(String message) {\r\n        super(message);\r\n    }\r\n}\r\n",
                "ErrorResponse.java": "package com.demo.demo.exceptions;\r\n\r\nimport lombok.AllArgsConstructor;\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\n\r\n@Setter\r\n@Getter\r\n@AllArgsConstructor\r\npublic class ErrorResponse {\r\n    private String details;\r\n    private Integer statusCode;\r\n    private String message;\r\n}",
                "GlobalExceptionHandler.java": "package com.demo.demo.exceptions;\r\nimport org.springframework.http.HttpHeaders;\r\nimport org.springframework.http.HttpStatus;\r\nimport org.springframework.http.HttpStatusCode;\r\nimport org.springframework.http.ResponseEntity;\r\nimport org.springframework.validation.FieldError;\r\nimport org.springframework.validation.ObjectError;\r\nimport org.springframework.web.bind.MethodArgumentNotValidException;\r\nimport org.springframework.web.bind.annotation.ExceptionHandler;\r\nimport org.springframework.web.bind.annotation.RestControllerAdvice;\r\nimport org.springframework.web.context.request.WebRequest;\r\nimport org.springframework.web.servlet.mvc.method.annotation.ResponseEntityExceptionHandler;\r\n\r\nimport java.util.HashMap;\r\nimport java.util.List;\r\nimport java.util.Map;\r\n\r\n@RestControllerAdvice\r\n\r\npublic class GlobalExceptionHandler extends ResponseEntityExceptionHandler {\r\n    @Override\r\n    protected ResponseEntity<Object> handleMethodArgumentNotValid(\r\n            MethodArgumentNotValidException ex, HttpHeaders headers, HttpStatusCode status, WebRequest request) {\r\n        Map<String, String> validationErrors = new HashMap<>();\r\n        List<ObjectError> validationErrorList = ex.getBindingResult().getAllErrors();\r\n\r\n        validationErrorList.forEach((error) -> {\r\n            String fieldName = ((FieldError) error).getField();\r\n            String validationMsg = error.getDefaultMessage();\r\n            validationErrors.put(fieldName, validationMsg);\r\n        });\r\n        return new ResponseEntity<>(validationErrors, HttpStatus.BAD_REQUEST);\r\n    }\r\n\r\n\r\n\r\n    @ExceptionHandler(BadRequestException.class)\r\n    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex ,WebRequest request) {\r\n        ErrorResponse error = new ErrorResponse(\r\n                ex.getMessage(),\r\n                ex.getStatusCode(),\r\n                request.getDescription(false)\r\n        );\r\n        return ResponseEntity.status(ex.getStatusCode())\r\n                .body(error);\r\n    }\r\n    @ExceptionHandler(NotFoundException.class)\r\n    public ResponseEntity<ErrorResponse> handleNotFoundException(NotFoundException ex ,WebRequest request) {\r\n        ErrorResponse error = new ErrorResponse(\r\n                ex.getMessage(),\r\n                ex.getStatusCode(),\r\n                request.getDescription(false)\r\n        );\r\n        return ResponseEntity.status(ex.getStatusCode())\r\n                .body(error);\r\n    }\r\n\r\n    @ExceptionHandler(Exception.class)\r\n    public ResponseEntity<ErrorResponse> handleExceptionF(Exception ex ,WebRequest request) {\r\n        ErrorResponse error = new ErrorResponse(\r\n                ex.getMessage(),\r\n                500,\r\n                request.getDescription(false)\r\n        );\r\n        return ResponseEntity.status(500)\r\n                .body(error);\r\n    }\r\n\r\n\r\n}\r\n",
                "NotFoundException.java": "package com.demo.demo.exceptions;\r\n\r\nimport lombok.Getter;\r\nimport lombok.Setter;\r\n\r\n@Getter\r\n@Setter\r\npublic class NotFoundException extends RuntimeException {\r\n    private Integer statusCode = 404;\r\n    public NotFoundException(String message) {\r\n        super(message);\r\n    }\r\n}\r\n"
              },
              "repositories": {
                "RoleRepository.java": "package com.demo.demo.repositories;\r\n\r\nimport com.demo.demo.entities.RoleEntity;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.data.jpa.repository.Query;\r\nimport org.springframework.data.repository.query.Param;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.util.Optional;\r\nimport java.util.UUID;\r\n@Repository\r\npublic interface RoleRepository extends JpaRepository<RoleEntity, UUID> {\r\n    @Query(value = \"SELECT r from  RoleEntity r where r.roleName = :name\")\r\n    Optional<RoleEntity> findRoleByName(@Param(\"name\") String name);\r\n}\r\n",
                "UserRepository.java": "package com.demo.demo.repositories;\r\n\r\nimport com.demo.demo.entities.UserEntity;\r\nimport org.springframework.data.jpa.repository.JpaRepository;\r\nimport org.springframework.stereotype.Repository;\r\n\r\nimport java.util.Optional;\r\n\r\n@Repository\r\npublic interface UserRepository extends JpaRepository<UserEntity, Long> {\r\n    Optional<UserEntity> findByUsername(String username);\r\n}\r\n"
              },
              "services": {
                "AuthService.java": "package com.demo.demo.services;\r\n\r\nimport com.demo.demo.dtos.request.LoginRequestDto;\r\nimport com.demo.demo.dtos.request.RegisterRequestDto;\r\nimport com.demo.demo.dtos.response.AuthResponseDto;\r\n\r\npublic interface AuthService {\r\n    AuthResponseDto login(LoginRequestDto dto);\r\n    AuthResponseDto register(RegisterRequestDto dto);\r\n}\r\n",
                "impl": {
                  "AuthServiceImpl.java": "package com.demo.demo.services.impl;\r\n\r\n\r\nimport com.demo.demo.dtos.request.LoginRequestDto;\r\nimport com.demo.demo.dtos.request.RegisterRequestDto;\r\nimport com.demo.demo.dtos.response.AuthResponseDto;\r\nimport com.demo.demo.entities.RoleEntity;\r\nimport com.demo.demo.entities.UserEntity;\r\nimport com.demo.demo.exceptions.BadRequestException;\r\nimport com.demo.demo.exceptions.NotFoundException;\r\nimport com.demo.demo.repositories.RoleRepository;\r\nimport com.demo.demo.repositories.UserRepository;\r\nimport com.demo.demo.services.AuthService;\r\nimport com.demo.demo.config.security.JwtUtil;\r\nimport jakarta.transaction.Transactional;\r\nimport lombok.RequiredArgsConstructor;\r\nimport org.springframework.security.authentication.AuthenticationManager;\r\nimport org.springframework.security.authentication.UsernamePasswordAuthenticationToken;\r\nimport org.springframework.security.crypto.password.PasswordEncoder;\r\nimport org.springframework.stereotype.Service;\r\n\r\nimport java.util.Optional;\r\n\r\n@Service\r\n@RequiredArgsConstructor\r\npublic class AuthServiceImpl implements AuthService {\r\n    private final UserRepository userRepository;\r\n    private final RoleRepository roleRepository;\r\n    private final PasswordEncoder passwordEncoder;\r\n    private final AuthenticationManager authenticationManager;\r\n    private final JwtUtil jwtUtil;\r\n    @Override\r\n    public AuthResponseDto login(LoginRequestDto dto) {\r\n        try {\r\n            authenticationManager\r\n                    .authenticate(new UsernamePasswordAuthenticationToken(dto.getEmail(), dto.getPassword()));\r\n        } catch (Exception e) {\r\n            throw new BadRequestException(\"Invalid username or password\");\r\n        }\r\n        UserEntity user = userRepository.findByUsername(dto.getEmail())\r\n                .orElseThrow(() -> new NotFoundException(String.format(\"User not found with email: %s\",dto.getEmail())));\r\n        String token = jwtUtil.generateToken(user);\r\n        return new AuthResponseDto(token);\r\n    }\r\n\r\n    @Override\r\n    @Transactional\r\n    public AuthResponseDto register(RegisterRequestDto dto) {\r\n        Optional<UserEntity> userFound = userRepository.findByUsername(dto.getEmail());\r\n        if(userFound.isPresent()) throw new BadRequestException(String.format(\"Email is already registered: %s\",dto.getEmail()));\r\n        RoleEntity role = roleRepository.findRoleByName(\"ROLE_USER\").orElseThrow(() -> new NotFoundException(String.format(\"Role not found with name %s\",\"ROLE_USER\")));\r\n        UserEntity user = new UserEntity();\r\n        user.setUsername(dto.getEmail());\r\n        user.setPassword(passwordEncoder.encode(dto.getPassword()));\r\n        user.getRoles().add(role);\r\n        userRepository.save(user);\r\n        String token = jwtUtil.generateToken(user);\r\n        return new AuthResponseDto(token);\r\n    }\r\n}\r\n"
                },
                "UserService.java": "package com.demo.demo.services;\r\n\r\nimport com.demo.demo.entities.UserEntity;\r\nimport com.demo.demo.repositories.UserRepository;\r\nimport org.springframework.security.core.userdetails.User;\r\nimport org.springframework.security.core.userdetails.UserDetails;\r\nimport org.springframework.security.core.userdetails.UserDetailsService;\r\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\r\nimport org.springframework.stereotype.Service;\r\n\r\n@Service\r\npublic class UserService implements UserDetailsService {\r\n\r\n    private final UserRepository userRepository;\r\n\r\n    public UserService(UserRepository userRepository) {\r\n        this.userRepository = userRepository;\r\n    }\r\n\r\n    @Override\r\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\r\n        UserEntity user = userRepository.findByUsername(username)\r\n                .orElseThrow(() -> new UsernameNotFoundException(\"User not found\"));\r\n\r\n        return user;\r\n    }\r\n}\r\n"
              }
            }
          }
        }
      },
      "resources": {
        "application.properties": "spring.application.name=demo\r\nspring.config.import=optional:file:.env[.properties]\r\nspring.datasource.url=${SPRING_DATASOURCE_URL}\r\nspring.datasource.username=${SPRING_DATASOURCE_USERNAME}\r\nspring.datasource.password=${SPRING_DATASOURCE_PASSWORD}\r\nspring.jpa.hibernate.ddl-auto=create\r\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect\r\n\r\n\r\n#google\r\nspring.security.oauth2.client.registration.google.client-id=${GOOGLE_ID}\r\ngoogle.client-id=${GOOGLE_ID}\r\n\r\nspring.security.oauth2.client.registration.google.client-secret=${GOOGLE_SECRET}\r\nspring.security.oauth2.client.registration.google.scope=email, profile\r\nspring.security.oauth2.client.registration.google.redirect-uri=${BACKEND_URL}oauth2/callback/google\r\n\r\n\r\nlogging.level.org.springframework.security=TRACE\r\n\r\n\r\njwt.secret=fGgqglUxy7KJoMO+b06brLZnK6qbzxDFpzrqE1OSHGI=\r\n\r\nfrontend.url=${FRONTEND_URL}\r\nbackend.url=${BACKEND_URL}",
        "import.sql": "INSERT INTO roles (role_id,role_name) VALUES('340ddc49-1214-4e00-9a77-2334334b23d3','ROLE_USER');\r\nINSERT INTO roles (role_id,role_name) VALUES('1b34df4b-b80c-425d-a87b-4eaaf8ae4515','ROLE_ADMIN');"
      }
    },
    "test": {
      "java": {
        "com": {
          "demo": {
            "demo": {
              "DemoApplicationTests.java": "package com.demo.demo;\n\nimport org.junit.jupiter.api.Test;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\nclass DemoApplicationTests {\n\n\t@Test\n\tvoid contextLoads() {\n\t}\n\n}\n"
            }
          }
        }
      }
    }
  }
}